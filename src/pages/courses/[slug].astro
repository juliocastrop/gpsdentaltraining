---
/**
 * Course Detail Page - GPS Dental Training
 * Template router: delegates rendering to Modern or Classic template
 * based on event.layout_template column
 */
import '../../styles/global.css';
import { getSiteSettings } from '../../lib/data/site-settings-loader';
const siteSettings = await getSiteSettings();
import { getEventBySlug, getMediaUrl } from '../../lib/strapi/client';
import { getEventWithSpeakers, getEventAvailability, getEventBySlug as getSupabaseEventBySlug } from '../../lib/supabase/queries';
import { supabase } from '../../lib/supabase/client';
import type { ScheduleTopic } from '../../types/database';

// Template components
import ModernCourseDetail from '../../components/templates/courses/ModernCourseDetail.astro';
import ClassicCourseDetail from '../../components/templates/courses/ClassicCourseDetail.astro';

const { slug } = Astro.params;

if (!slug) {
  return Astro.redirect('/courses');
}

let event: any;
let availability: any;
let eventId: string;

// Try Strapi first, then fall back to Supabase
try {
  const strapiEvent = await getEventBySlug(slug);

  if (strapiEvent) {
    // Transform Strapi event to match expected format
    event = {
      id: String(strapiEvent.id),
      title: strapiEvent.title,
      slug: strapiEvent.slug,
      description: strapiEvent.description,
      start_date: strapiEvent.startDate,
      end_date: strapiEvent.endDate,
      venue: strapiEvent.venue,
      address: strapiEvent.address,
      ce_credits: strapiEvent.ceCredits || 0,
      capacity: strapiEvent.capacity,
      featured_image_url: getMediaUrl(strapiEvent.featuredImage),
      gallery_images: strapiEvent.galleryImages?.data?.map((img: any) => getMediaUrl({ data: img })).filter(Boolean) || [],
      video_url: null,
      schedule_topics: strapiEvent.scheduleTopics,
      learning_objectives: strapiEvent.learningObjectives,
      speakers: strapiEvent.speakers?.data?.map((s: any) => ({
        id: String(s.id),
        name: s.attributes.name,
        slug: s.attributes.slug,
        title: s.attributes.title,
        bio: s.attributes.bio,
        photo_url: getMediaUrl(s.attributes.photo),
        social_links: {
          linkedin: s.attributes.linkedIn,
          twitter: s.attributes.twitter,
          website: s.attributes.website,
        },
      })) || [],
    };

    // Get Supabase event ID for transactional data (tickets, availability)
    try {
      const supabaseEvent = await getSupabaseEventBySlug(slug);
      eventId = supabaseEvent?.id || strapiEvent.id.toString();
      // Merge layout_template from Supabase if available
      if (supabaseEvent?.layout_template) {
        event.layout_template = supabaseEvent.layout_template;
      }
    } catch {
      eventId = strapiEvent.id.toString();
    }
  } else {
    // Fall back to Supabase
    event = await getEventWithSpeakers(slug);
    eventId = event.id;
  }

  // Always get availability from Supabase (transactional data)
  availability = await getEventAvailability(eventId);
} catch (error) {
  console.error('Error loading event:', error);
  return Astro.redirect('/courses');
}

// Fetch event_schedules from Supabase (the proper schedule table)
let eventSchedules: Array<{ schedule_date: string; tab_label: string | null; topics: any[]; display_order: number }> = [];
try {
  const { data: schedulesData } = await supabase
    .from('event_schedules')
    .select('schedule_date, tab_label, topics, display_order')
    .eq('event_id', eventId)
    .order('display_order', { ascending: true })
    .order('schedule_date', { ascending: true });

  if (schedulesData && schedulesData.length > 0) {
    eventSchedules = schedulesData;
  }
} catch {
  // Table may not exist or query failed - fall back to schedule_topics
}

// Helper functions
function formatDate(dateStr: string): string {
  return new Date(dateStr).toLocaleDateString('en-US', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });
}

function formatDateShort(dateStr: string): string {
  return new Date(dateStr).toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric',
  });
}

function formatDateRange(startDate: string, endDate: string | null): string {
  const start = new Date(startDate);
  if (!endDate) return formatDate(startDate);

  const end = new Date(endDate);
  if (start.getMonth() === end.getMonth() && start.getFullYear() === end.getFullYear()) {
    return `${start.toLocaleDateString('en-US', { month: 'long' })} ${start.getDate()}-${end.getDate()}, ${start.getFullYear()}`;
  }
  return `${formatDateShort(startDate)} - ${formatDateShort(endDate)}`;
}

// Interface for new schedule format from WordPress migration
interface MigratedScheduleTopic {
  name: string;
  start_time: string;
  end_time: string;
  speakers: number[];
  location: string;
  description: string;
}

interface MigratedSchedule {
  date: string;
  tab_label: string;
  topics: MigratedScheduleTopic[];
}

interface MigratedScheduleData {
  objectives?: string[];
  schedules?: MigratedSchedule[];
}

// Parse schedule_topics which can be in old format (array of ScheduleTopic) or new format (MigratedScheduleData)
function parseScheduleData(scheduleTopics: any): { objectives: string[], schedules: MigratedSchedule[] } {
  if (!scheduleTopics) {
    return { objectives: [], schedules: [] };
  }

  // Check if it's the new migrated format with objectives and schedules
  if (scheduleTopics.objectives || scheduleTopics.schedules) {
    return {
      objectives: scheduleTopics.objectives || [],
      schedules: scheduleTopics.schedules || [],
    };
  }

  // Old format: array of ScheduleTopic with day, time, topic
  if (Array.isArray(scheduleTopics)) {
    // Group by day and convert to new format
    const grouped = new Map<number, ScheduleTopic[]>();
    for (const topic of scheduleTopics) {
      const day = topic.day || 1;
      if (!grouped.has(day)) grouped.set(day, []);
      grouped.get(day)!.push(topic);
    }

    const schedules: MigratedSchedule[] = [];
    for (const [day, topics] of grouped) {
      schedules.push({
        date: '', // Old format doesn't have dates
        tab_label: `Day ${day}`,
        topics: topics.map(t => ({
          name: t.topic,
          start_time: t.time?.split(' - ')[0] || '',
          end_time: t.time?.split(' - ')[1] || '',
          speakers: [],
          location: '',
          description: t.description || '',
        })),
      });
    }

    return { objectives: [], schedules };
  }

  return { objectives: [], schedules: [] };
}

const dateDisplay = formatDateRange(event.start_date, event.end_date);
const cleanTitle = event.title.replace('[TEST] ', '');

// Use event_schedules table (preferred) or fall back to schedule_topics JSONB
let migratedSchedules: MigratedSchedule[] = [];
let migratedObjectives: string[] = [];

if (eventSchedules.length > 0) {
  // Use the proper event_schedules table data
  migratedSchedules = eventSchedules.map(s => ({
    date: s.schedule_date || '',
    tab_label: s.tab_label || '',
    topics: (s.topics || []).map((t: any) => ({
      name: t.name || '',
      start_time: t.start_time || '',
      end_time: t.end_time || '',
      speakers: t.speakers || [],
      location: t.location || '',
      description: t.description || '',
    })),
  }));
} else {
  // Fall back to schedule_topics on events table
  const parsed = parseScheduleData(event.schedule_topics);
  migratedSchedules = parsed.schedules;
  migratedObjectives = parsed.objectives;
}

const isUpcoming = new Date(event.start_date) > new Date();
const dayCount = migratedSchedules.length;

// Learning objectives - from database field or extract from description as fallback
function extractObjectivesFromDescription(description: string | null): string[] {
  if (!description) return [];

  // Look for "Learning Objectives" section in HTML
  const objectivesMatch = description.match(/<h3>Learning Objectives<\/h3>\s*<ul>([\s\S]*?)<\/ul>/i);
  if (objectivesMatch) {
    const listContent = objectivesMatch[1];
    const items = listContent.match(/<li>([\s\S]*?)<\/li>/gi);
    if (items) {
      return items.map(item => item.replace(/<\/?li>/gi, '').trim());
    }
  }
  return [];
}

// Also remove Learning Objectives section from description if we're displaying them separately
function removeObjectivesFromDescription(description: string | null): string | null {
  if (!description) return null;
  return description.replace(/<h3>Learning Objectives<\/h3>\s*<ul>[\s\S]*?<\/ul>/i, '');
}

// Priority: migrated objectives > learning_objectives field > extracted from description
const learningObjectives = migratedObjectives.length > 0
  ? migratedObjectives
  : (event.learning_objectives && event.learning_objectives.length > 0
    ? event.learning_objectives
    : extractObjectivesFromDescription(event.description));

// Clean description if we extracted objectives from it
const cleanDescription = learningObjectives.length > 0 && !event.learning_objectives && migratedObjectives.length === 0
  ? removeObjectivesFromDescription(event.description)
  : event.description;

// Check if event is sold out
const isSoldOut = availability?.is_sold_out || false;

// Determine which template to use
const layoutTemplate = event.layout_template || 'modern';

// Template props
const templateProps = {
  event,
  availability,
  siteSettings,
  cleanTitle,
  cleanDescription,
  dateDisplay,
  learningObjectives,
  migratedSchedules,
  isUpcoming,
  isSoldOut,
  dayCount,
  url: Astro.url,
};
---

{layoutTemplate === 'classic' ? (
  <ClassicCourseDetail {...templateProps} />
) : (
  <ModernCourseDetail {...templateProps} />
)}
